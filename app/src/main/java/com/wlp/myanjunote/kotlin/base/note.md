## 00入门词
稀土掘金-朱涛的自习室
https://juejin.cn/user/2119514149637032/posts

1、Java相对Kotlin的一些缺点
（1）语法表现力差。
比如，Java 1.8 之前不支持 Lambda 表达式，匿名内部的写法繁琐；在函数方面，不支持高阶函数，不支持参
数默认值，也不支持函数命名参数。
（2）可读性差，难维护
语法表现力的问题进一步演变成可读性问题、维护性问题。
比如Java中Callback的嵌套
（3）Java自身的语法设计也使它更容易出错
比如，Java 基础类型的隐式转换，你可以直接将字符变量赋值给整型变量，而编译器也不会报错。再比如，Java
的内部类会偷偷持有外部类的引用，从而在某些场景中导致内存泄漏。
（4）并发编程，在 Java 当中也是一大难题。

以上 Java 的所有缺陷，最终反映到实际工作中，就会变成：前期开发效率低，中期线上问题多，后期代码难维
护。

2、为什么Kotlin值得学习
（1）极高的生产效率
（2）强大的兼容性
Kotlin可以与Java混合编程
（3）Kotlin 的发展前景很广阔，Google 宣布 Kotlin 成为 Android 的官方语言

3、Kotlin学习的难点，易学难精
不变性：kotlin定义一个变量、集合时，明确规定了它的不变性
空安全：类型分为可空和不可控类型
表达式：if\else\when之类的语句，还可以作为表达式使用
函数：拥抱函数式编程
协程：这个很重要，


？？？4.问题 todo
挂起函数，挂起的是谁？
说到协程，我们一直使用的场景更多是串联场景好像？
那其他一些场景呢并联 + 串联呢？


## 03 | Kotlin原理：编译器在幕后干了哪些“好事”？
1、Kotlin 与 JVM
首先，我们写的 Kotlin 代码，编译器会以一定的规则将其翻译成 Java 字节码。这种字节码是专门为 JVM 而
设计的，它的语法思想和汇编代码有点接近。

接着，JVM 拿到字节码以后，会根据特定的语法来解析其中的内容，理解其中的含义，并且让字节码运行起来。

那么，JVM 到底是如何让字节码运行起来的呢？其实，JVM 是建立在操作系统之上的一层抽象运行环境。

JVM与硬件直接的适配层？

JVM 定义了一套字节码规范，只要是符合这种规范的，都可以在 JVM 当中运行。至于 JVM 是如何跟不同的
操作系统打交道的，我们不管。

2、将 Kotlin 转换成字节码后，再将字节码反编译成等价的 Java 代码。最终，
我们去分析等价的 Java 代码，通过这样的方式来理解 Kotlin 的实现细节。

Tools -> Kotlin -> Show Kotlin Bytecode

只要基础类型的变量可能为空，那么这个变量就会被转换成 Java 的包装类型。
反之，只要基础类型的变量不可能为空，那么这个变量就会被转换成 Java 的原始类型

3、接口的“成员属性”，是 Kotlin 独有的。请问它的局限性在哪？
从上面的 Java 代码中我们能看出来，Kotlin 接口的“默认属性”canWalk，本质上并不是一个真正的属性，
当它转换成 Java 以后，就变成了一个普通的接口方法 getCanWalk()。

另外，Kotlin 接口的“方法默认实现”，它本质上也没有直接提供实现的代码。对应的，它只是在接口当中定义
了一个静态内部类“DefaultImpls”，然后将默认实现的代码放到了静态内部类当中去了。

Kotlin 接口当中的属性，在它被真正实现之前，本质上并不是一个真正的属性。因此，Kotlin 接口当中的属性，
它既不能真正存储任何状态，也不能被赋予初始值，因为它本质上还是一个接口方法。

4、我们举一些更具体的例子：
类型推导，我们写 Kotlin 代码的时候省略的变量类型，最终被编译器补充回来了。
原始类型，虽然 Kotlin 没有原始类型，但编译器会根据每一个变量的可空性将它们转换成“原始类型”或者“包
装类型”。
字符串模板，编译器最终会将它们转换成 Java 拼接的形式。
when 表达式，编译器最终会将它们转换成类似 switch case 的语句。
类默认 public，Kotlin 当中被我们省略掉 public，最终会被编译器补充。
嵌套类默认 static，我们在 Kotlin 当中的嵌套类，默认会被添加 static 关键字，将其变成静态内部类，防止
不必要的内存泄漏。
数据类，Kotlin 当中简单的一行代码“data class Person(val name: String, val age: Int)”，编译器帮我们自
动生成很多方法：getter()、setter()、equals()、hashCode()、toString()、componentN()、copy()。

